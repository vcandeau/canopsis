#!/bin/bash
#--------------------------------
# Copyright (c) 2011 "Capensis" [http://www.capensis.com]
#
# This file is part of Canopsis.
#
# Canopsis is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Canopsis is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Canopsis.  If not, see <http://www.gnu.org/licenses/>.
# ---------------------------------

build_install_deps_tree () {
	init_tmp
	log_info "Create deps tree"
	parse_install_deps $@
	clean_tree
	trap 'error ${LINENO} "Remove tmp file ($TMP_FILE)"' ERR
	#rm -Rf $TMP_FILE	
}

build_remove_deps_tree () {
	init_tmp
	parse_remove_deps $@
	trap 'error ${LINENO} "Remove tmp file ($TMP_FILE)"' ERR
	rm -Rf $TMP_FILE	
}

init_tmp () {
	trap 'error ${LINENO} "Remove tmp file ($TMP_FILE)"' ERR
	rm -Rf $TMP_FILE
	trap 'error ${LINENO} "Touch tmp file ($TMP_FILE)"' ERR
	touch $TMP_FILE
}

clean_tree () {
	pkg_list_deps=$(sed 's# #\n#g' $TMP_FILE | awk ' !x[$0]++')
}

parse_install_deps () {
	D_TREE="$@ $D_TREE"
	for dep in $@; do
		local tmp
		trap 'error ${LINENO} "Package $dep must be install but its not available on repositorie"' ERR
		tmp=$(cat $REMOTE_DB_PATH | grep "^$dep|" | tail -n1 | wc -l)
		if [ $tmp -le 0 ]; then
			exit 1
		else
			local DBINFO=$(cat $REMOTE_DB_PATH | grep "^$dep|" | tail -n1)
			local L_DEPS=$(db_parse "deps" "$DBINFO")
			if [ -z "$L_DEPS" ]; then 
				NB_DEPS=0
			else 
				NB_DEPS=$(echo $L_DEPS | sed 's# #\n#g' | wc -l)
			fi

			if [ $NB_DEPS -gt 0 ]; then
				parse_install_deps $L_DEPS
			else
				echo "$L_DEPS $D_TREE" > $TMP_FILE
			fi
		fi
	done
}

parse_remove_deps () {
    D_TREE="$@"
	# Check if packages pending to be removed are not used by other
	# For each package in argument
	for dep in $D_TREE; do
		DBINFO=$(cat $REMOTE_DB_PATH | grep "^$dep|" | tail -n1)
        L_DEPS=$(db_parse "deps" "$DBINFO")
		D_TREE="$D_TREE $L_DEPS"
	done
	# For each package in full list
	for dep in $D_TREE; do
		DBINFO=$(cat $REMOTE_DB_PATH | grep "^$dep|" | tail -n1)
        L_DEPS=$(db_parse "deps" "$DBINFO")
		# For each dependencies of this package
		for s_dep in $L_DEPS; do
			T_LINE="$s_dep needed by:"
            T_LIST=""
			stat="false"
			# Read each line of installed list package
			while read line; do
				T_PNAME=$(echo "$line" | cut -d '|' -f1)
				T_DEPS=$(db_parse "deps" "$line")
				# For each dependencies of this installed package	
				for t_dep in $T_DEPS; do
					# If it's initial package itself, continue
					if [ "$T_PNAME" == "$dep" ]; then
						break
					fi
					if [ "$s_dep" == "$t_dep" ]; then
						D_TREE=$(echo "$D_TREE" | sed 's/'$s_dep//)
						stat="true"
						T_LIST="$T_LIST $s_dep"
					fi
				done
			done < "$LOCAL_DB_PATH"
			if [ "$stat" == "true" ]; then
            	echo "$T_LINE $T_LIST" >> $TMP_FILE
            fi
		done 
	done
	echo $D_TREE
}

send_removal_conflicts () {
	awk '!x[$0]++' $TMP_FILE
	trap 'error ${LINENO} "Remove tmp file ($TMP_FILE)"' ERR
	rm -Rf $TMP_FILE
}
